# This file has ben automatically generated by stubgen
# DO NOT EDIT
#
module TensorStream
  module OpStub

    ##
    # Returns x + y element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def add(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:add, input_a, input_b, name: name)
    end


    ##
    # Returns the index with the largest value across axes of a tensor.
    #
    #
    # @param input_a tensor X (of type NUMERIC_TYPES)
    # @param axis Describes which axis of the input tensor to reduce across. For vectors, use axis = 0 (of type INTEGER_TYPES)
    #
    # Options:
    # @option name Optional name
    # @option dimension Same as axis
    # @option output_type Output data type defaults to int32 default (:int32)
    # @return Tensor
    def argmax(input_a, axis = nil, name: nil, dimension: nil, output_type: :int32)
      check_allowed_types(input_a, TensorStream::Ops::NUMERIC_TYPES)
      check_allowed_types(axis, TensorStream::Ops::INTEGER_TYPES)
      _op(:argmax, input_a, axis, name: name, dimension: dimension, output_type: output_type)
    end


    ##
    # Returns the index with the smallest value across axes of a tensor.
    #
    #
    # @param input_a tensor X (of type NUMERIC_TYPES)
    # @param axis Describes which axis of the input tensor to reduce across. For vectors, use axis = 0 (of type INTEGER_TYPES)
    #
    # Options:
    # @option name Optional name
    # @option dimension Same as axis
    # @option output_type Output data type defaults to int32 default (:int32)
    # @return Tensor
    def argmin(input_a, axis = nil, name: nil, dimension: nil, output_type: :int32)
      check_allowed_types(input_a, TensorStream::Ops::NUMERIC_TYPES)
      check_allowed_types(axis, TensorStream::Ops::INTEGER_TYPES)
      _op(:argmin, input_a, axis, name: name, dimension: dimension, output_type: output_type)
    end


    ##
    # Returns element-wise smallest integer in not less than x
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def ceil(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:ceil, input_a, name: name)
    end


    ##
    # Computes cos of input element-wise.
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def cos(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:cos, input_a, name: name)
    end


    ##
    # Returns x / y element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def div(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:div, input_a, input_b, name: name)
    end


    ##
    # Returns the truth value of (x == y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def equal(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:equal, input_a, input_b, name: name)
    end


    ##
    # Inserts a dimension of 1 into a tensor's shape. 
    # Given a tensor input, this operation inserts a dimension of 1 at the dimension index axis of input's shape. The 
    # dimension index axis starts at zero; if you specify a negative number for axis it is counted backward from the end.
    #
    #
    # @param input A tensor
    # @param axis Specifies the dimension index at which to expand the shape of input. Must be in the range [-rank(input) - 1, rank(input)].
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def expand_dims(input, axis, name: nil)
      _op(:expand_dims, input, axis, name: name)
    end


    ##
    # This operation creates a tensor of shape dims and fills it with value.
    #
    #
    # @param dims tensor shape
    # @param value scalar value to fill with
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def fill(dims, value, name: nil)
      _op(:fill, dims, value, name: name)
    end


    ##
    # Returns element-wise largest integer not greater than x.
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def floor(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:floor, input_a, name: name)
    end


    ##
    # Returns element-wise integer divistion.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def floor_div(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:floor_div, input_a, input_b, name: name)
    end


    ##
    # Returns the truth value of (x > y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def greater(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:greater, input_a, input_b, name: name)
    end


    ##
    # Returns the truth value of (x >= y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def greater_equal(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:greater_equal, input_a, input_b, name: name)
    end


    ##
    # Returns the truth value of (x < y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def less(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:less, input_a, input_b, name: name)
    end


    ##
    # Returns the truth value of (x <= y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def less_equal(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:less_equal, input_a, input_b, name: name)
    end


    ##
    # Computes natural logarithm of x element-wise.
    #
    #
    # @param input tensor X
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def log(input, name: nil)
      _op(:log, input, name: name)
    end


    ##
    # Multiplies matrix a by matrix b, producing a * b. The inputs must, following any transpositions, be tensors of rank 2 .
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option transpose_a Transpose matrix A first default (false)
    # @option transpose_b Transpose matrix B first default (false)
    # @option name Optional name
    # @return Tensor
    def mat_mul(input_a, input_b, transpose_a: false, transpose_b: false, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:mat_mul, input_a, input_b, transpose_a: transpose_a, transpose_b: transpose_b, name: name)
    end

    alias_method :matmul, :mat_mul

    ##
    # Returns the max of x and y (i.e. x > y ? x : y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X (of type NUMERIC_TYPES)
    # @param input_b tensor Y (of type NUMERIC_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def max(input_a, input_b, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::NUMERIC_TYPES)
      check_allowed_types(input_b, TensorStream::Ops::NUMERIC_TYPES)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:max, input_a, input_b, name: name)
    end


    ##
    # Returns the min of x and y (i.e. x < y ? x : y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X (of type NUMERIC_TYPES)
    # @param input_b tensor Y (of type NUMERIC_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def min(input_a, input_b, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::NUMERIC_TYPES)
      check_allowed_types(input_b, TensorStream::Ops::NUMERIC_TYPES)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:min, input_a, input_b, name: name)
    end


    ##
    # Returns element-wise remainder of division.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def mod(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:mod, input_a, input_b, name: name)
    end


    ##
    # Returns x * y element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def mul(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:mul, input_a, input_b, name: name)
    end


    ##
    # Computes numerical negative value element-wise.
    #
    #
    # @param input tensor X
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def negate(input, name: nil)
      _op(:negate, input, name: name)
    end


    ##
    # Returns the truth value of (x != y) element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def not_equal(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:not_equal, input_a, input_b, name: name)
    end


    ##
    # Creates a tensor with all elements set to 1.
    # Given a single tensor (tensor), this operation returns a
    # tensor of the same type and shape as tensor with all elements set to 1.
    # Optionally, you can specify a new type (dtype) for the returned tensor.
    #
    #
    # @param input A tensor
    #
    # Options:
    # @option dtype Optional new data type to cast into
    # @option name Optional name
    # @return Tensor
    def ones_like(input, dtype: nil, name: nil)
      _op(:ones_like, input, data_type: dtype, name: name)
    end


    ##
    # Computes the power of one value to another X^Y element wise
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def pow(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:pow, input_a, input_b, name: name)
    end


    ##
    # Computes the product of elements across dimensions of a tensor.
    # Reduces input_tensor along the dimensions given in axis. Unless keepdims is true, the rank of the
    # tensor is reduced by 1 for each entry in axis. If keepdims is true, the reduced dimensions are
    # retained with length 1.
    # If axis has no entries, all dimensions are reduced, and a tensor with a single element is returned.
    #
    #
    # @param input_a tensor X
    # @param axis tensor X (of type INTEGER_TYPES)
    #
    # Options:
    # @option name Optional name
    # @option keepdims If true, retains reduced dimensions with length 1. default (false)
    # @return Tensor
    def prod(input_a, axis = nil, name: nil, keepdims: false)
      check_allowed_types(axis, TensorStream::Ops::INTEGER_TYPES)
      input_a = TensorStream.convert_to_tensor(input_a)
      return input_a if input_a.shape.scalar?
      axis = cast_axis(input_a, axis)
      _op(:prod, input_a, axis, name: name, keepdims: keepdims)
    end

    alias_method :reduce_prod, :prod

    ##
    # Outputs random values from a uniform distribution.
    #
    #
    # @param shape A 1-D integer Tensor or array. The shape of the output tensor.
    #
    # Options:
    # @option name Optional name
    # @option dtype The type of the output: float16, float32, float64, int32, or int64 default (:float32)
    # @option minval A 0-D Tensor or ruby value of type dtype. The lower bound on the range of random values to generate. Defaults to 0. default (0)
    # @option maxval A 0-D Tensor or ruby value of type dtype. The upper bound on the range of random values to generate. Defaults to 1 if dtype is floating point. default (1)
    # @option seed  A ruby integer. Used to create a random seed for the distribution. See set_random_seed for behavior.
    # @return Tensor
    def random_uniform(shape, name: nil, dtype: :float32, minval: 0, maxval: 1, seed: nil)
      _op(:random_uniform, shape, name: name, dtype: dtype, minval: minval, maxval: maxval, seed: seed)
    end


    ##
    # Creates a sequence of numbers.
    # Creates a sequence of numbers that begins at start and extends by increments of delta up to but not including limit.
    #
    #
    # @param start Acts as first entry in the range if limit is not nil; otherwise, acts as range limit and first entry defaults to 0.
    # @param limit Upper limit of sequence, exclusive. If nil, defaults to the value of start while the first entry of the range defaults to 0.
    # @param delta Number that increments start. Defaults to 1.
    #
    # Options:
    # @option name  A name for the operation. Defaults to "range". default ("range")
    # @option dtype The type of the elements of the resulting tensor.
    # @option output_type Output data type defaults to int32 default (:int32)
    # @return Tensor
    def range(start = 0, limit = 0, delta = 1, name: "range", dtype: nil, output_type: :int32)
      _op(:range, start, limit, delta, name: name, dtype: dtype, output_type: output_type)
    end


    ##
    # Returns the rank of a tensor
    #
    #
    # @param input A tensor
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def rank(input, name: nil)
      input = convert_to_tensor(input)
      return cons(input.shape.ndims) if input.shape.known?
      _op(:rank, input, name: name)
    end


    ##
    # Reshapes a tensor.
    # Given tensor, this operation returns a tensor that has the same values as tensor with shape shape.
    #
    #
    # @param input A tensor
    # @param shape A new tensor shape
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def reshape(input, shape, name: nil)
      _op(:reshape, input, shape, name: name)
    end


    ##
    # Rounds the values of a tensor to the nearest integer, element-wise
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def round(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:round, input_a, name: name)
    end


    ##
    # Computes reciprocal of square root of x element-wise.
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def rsqrt(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:rsqrt, input_a, name: name)
    end


    ##
    # This operation returns a 1-D integer tensor representing the shape of input
    #
    #
    # @param input A tensor
    #
    # Options:
    # @option name Optional name
    # @option out_type Optional output type default (:int32)
    # @return Tensor
    def shape(input, name: nil, out_type: :int32)
      return constant(shape_eval(input, out_type), dtype: out_type, name: "Shape/#{name}") if input.is_a?(Array) && !input[0].is_a?(Tensor)
      return constant(input.shape.shape, dtype: out_type, name: "Shape/#{input.name}_c") if shape_full_specified(input)
      _op(:shape, input, name: name, out_type: out_type)
    end


    ##
    # Computes sigmoid of x element-wise.
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def sigmoid(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:sigmoid, input_a, name: name)
    end


    ##
    # Computes sign of input element-wise.
    # <tt>y = sign(x) = -1 if x < 0; 0 if x == 0 or tf.is_nan(x); 1 if x > 0.</tt>
    # Zero is returned for NaN inputs.
    #
    #
    # @param input_a tensor X
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def sign(input_a, name: nil)
      _op(:sign, input_a, name: name)
    end


    ##
    # Computes sin of input element-wise.
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def sin(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:sin, input_a, name: name)
    end


    ##
    # Returns the size of a tensor.
    # Returns a 0-D Tensor representing the number of elements in input of type out_type. Defaults to :int32.
    #
    #
    # @param input A tensor
    #
    # Options:
    # @option name Optional name
    # @option out_type Optional output type default (:int32)
    # @return Tensor
    def size(input, name: nil, out_type: :int32)
      _op(:size, input, name: name, out_type: out_type)
    end


    ##
    # Extracts a strided slice of a tensor 
    # this op extracts a slice of size `(end-begin)/stride`
    #   from the given `input_` tensor. Starting at the location specified by `begin`
    #   the slice continues by adding `stride` to the index until all dimensions are
    #   not less than `end`.
    #   Note that a stride can be negative, which causes a reverse slice.
    #
    #
    # @param input A tensor
    # @param _begin start index
    # @param _end end index
    # @param strides end index
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def strided_slice(input, _begin, _end, strides = nil, name: nil)
      _op(:strided_slice, input, _begin, _end, strides, name: name)
    end


    ##
    # Returns x - y element-wise.
    #
    # This operation supports broadcasting
    #
    # @param input_a tensor X
    # @param input_b tensor Y
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def sub(input_a, input_b, name: nil)
      input_a, input_b = apply_data_type_coercion(input_a, input_b)
      _op(:sub, input_a, input_b, name: name)
    end

    alias_method :subtract, :sub

    ##
    # Computes the sum of elements across dimensions of a tensor.
    # Reduces input_tensor along the dimensions given in axis. Unless keepdims is true, the rank of the
    # tensor is reduced by 1 for each entry in axis. If keepdims is true, the reduced dimensions are
    # retained with length 1.
    # If axis has no entries, all dimensions are reduced, and a tensor with a single element is returned.
    #
    #
    # @param input_a tensor X
    # @param axis_p tensor X (of type INTEGER_TYPES)
    #
    # Options:
    # @option axis axis
    # @option name Optional name
    # @option keepdims If true, retains reduced dimensions with length 1. default (false)
    # @return Tensor
    def sum(input_a, axis_p = nil, axis: nil, name: nil, keepdims: false)
      check_allowed_types(axis_p, TensorStream::Ops::INTEGER_TYPES)
      input_a = TensorStream.convert_to_tensor(input_a)
      return input_a if input_a.shape.scalar?
      axis_p = axis_p || axis
      axis_p = cast_axis(input_a, axis_p)
      _op(:sum, input_a, axis_p, name: name, keepdims: keepdims)
    end

    alias_method :reduce_sum, :sum

    ##
    # Computes tan of input element-wise.
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def tan(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:tan, input_a, name: name)
    end


    ##
    # Computes tanh of input element-wise.
    #
    #
    # @param input_a tensor X (of type FLOATING_POINT_TYPES)
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def tanh(input_a, name: nil)
      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)
      _op(:tanh, input_a, name: name)
    end


    ##
    # Constructs a tensor by tiling a given tensor.
    # This operation creates a new tensor by replicating input multiples times.
    # The output tensor's i'th dimension has input.dims(i) * multiples[i] elements,
    # and the values of input are replicated multiples[i] times along the 'i'th dimension. For example, tiling [a b c d] by [2] produces [a b c d a b c d].
    #
    #
    # @param input A tensor
    # @param multiples Must be one of the following types: int32, int64. 1-D. Length must be the same as the number of dimensions in input
    #
    # Options:
    # @option name Optional name
    # @return Tensor
    def tile(input, multiples, name: nil)
      _op(:tile, input, multiples, name: name)
    end


    ##
    # Finds values and indices of the `k` largest entries for the last dimension.
    #
    #
    # @param input 1-D or higher `Tensor` with last dimension at least `k`.
    # @param k 0-D `int32` `Tensor`.  Number of top elements to look for along the last dimension (along each row for matrices)
    #
    # Options:
    # @option sorted If true the resulting `k` elements will be sorted by the values in descending order. default (true)
    # @option name Optional name
    # @return Tensor
    def top_k(input, k = 1, sorted: true, name: nil)
      result = _op(:top_k, input, k, sorted: sorted, name: name)
      [result[0], result[1]]
    end


    ##
    # Creates a tensor with all elements set to zero
    #
    #
    # @param shape A 1-D integer Tensor or ruby array. The shape of the output tensor.
    #
    # Options:
    # @option dtype Optional name default (:float32)
    # @option name Optional name
    # @return Tensor
    def zeros(shape, dtype: :float32, name: nil)
      _op(:zeros, shape, dtype: dtype, name: name)
    end


  end
end